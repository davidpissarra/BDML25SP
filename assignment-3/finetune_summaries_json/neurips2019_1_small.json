{
    "question": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nCutting Knowledge Date: December 2023\nToday Date: 26 Jul 2024\n\n<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nThe following text is noisy and dirty, so please rephrase the following text while removing noisy text (e.g., incorrect characters coming from the pdf reader, emails, footnotes, etc.), but without removing important content or adding new data, however keep as much data as possible:\n\n\" four orders of magnitude faster or can warm-start the optimizer for 3.75x faster convergence. This allows us to dis- pense with linear approximation, leads to more efﬁcient generator dispatch, and can potentially save hundreds of megatons of CO2-equivalent. 1 Introduction With a share of 25%, electricity and heat production make up a signiﬁcant component of the yearly emissions of roughly 50GtCO 2-eq.(IPCC 2014, p. 46f). Accordingly, any increase in efﬁciency has the potential of a large impact. At the same time, energy supply is an extremely critical and sensitive system, in which blackouts and brownouts are unacceptable. Any new technology deployed here needs to guarantee correctness. Day-to-day operating of an electrical grid requires scheduling of generator outputs. A Transmission System Operator (TSO) needs to optimize the purchase of power from different generators, each of which has different and potentially nonlinear costs and CO 2emissions per produced MJ. Minimiz- ing cost is known as Optimal Power Flow (OPF), and optimizing it exactly (referred to as ACOPF) has been proven to be NP-hard (Bienstock and Verma 2015). In the future, the problem size is bound to increase even more with the proliferation of small renewable generators. Great progress has been achieved in the last decades (refer to Cain et al. (2012) for an overview). Yet, particularly in day-to-day operations which require solving OPF within a minute every ﬁve minutes, TSOs are forced to rely on linear approximations known as DCOPF. Solutions produced by these approximations are inefﬁcient and therefore waste power and overproduce hundreds of megatons of CO2-equivalent per year. We propose to use machine learning to produce a solution to the OPF problem. Knowing that such a solution will not necessarily be optimal or even legal (i.e. physically implementable), we can then use it to warm-start an ACOPF solver. Combining both approaches, we gain the best of both worlds: A signiﬁcantly faster execution time and guaranteed legality. This has previously been proposed by Guha et al. (2019). However, they used a feed-forward net- work and therefore have issues with both scalability and changing network geometry. They also did not integrate their results in an actual ACOPF optimizer. 33rd Conference on Neural Information Processing Systems (NeurIPS 2019), Vancouver, Canada.2 Approach and Experiments OPF is a complex problem governed by a great number of non-linear equations and constraints. We refer the reader to Frank and Rebennack (2016) for details on the problem formulation. For the following, we approximate the problem as a graph: There are physical busses (each of which might contain loads, generators, and/or shunts) connected by branches. Each component is characterized by both physical parameters (for example a branch’s resistance) and constraints (for example a generator’s maximum power output). By modelling the problem as a graph, we can apply GNNs to it. This approach allows us indepen- dence of the actual net topology, is data-efﬁcient, and is suited to the sparse connectivity of a power network. We rely on PowerModels.jl (Coffrin et al. 2018), and use IPOPT (Wächter and Biegler 2006) as an OPF solver. We implement the model using pytorch (Paszke et al. 2017) and the pytorch-geometric package (Fey and Lenssen 2019). 2.1 Model In most applications and benchmarks, GNNs expect to have a set of homogeneously-typed nodes and edges connecting these. While we normally could model a bus’ generator as being part of that bus, several generators can be linked to one bus. We therefore treat busses as connecting to sets of generators, loads, and shunts. Following Zaheer et al. (2017), we compute a representation of each of these components, then concatenate their summed features to the bus: ch=fn c( ci), o0=fn o bi∥∑ s∈Nsh∥∑ g∈Ngh∥∑ l∈Nlh , (1) wherecis one ofs,b,g, andl(the shunt, bus, generator, and load features),iare the input features, hthe encoded representation,0the0th layer output, fare a set of learned functions (parameterized neural networks), and ∥is concatenation. Nrefers to the corresponding neighbours of each node. Afterwards, we compute edge features eand node features for layer nas en=fn e( bn∥en−1∥on), bn=fb\".<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\n",
    "answer": "Here's the rephrased text with the noisy characters and text removed:\n\nThe proposed approach can achieve four orders of magnitude faster execution or warm-start the optimizer for 3.75 times faster convergence. This allows us to dispense with linear approximation, leading to more efficient generator dispatch, and potentially saving hundreds of megatons of CO2-equivalent emissions. \n\nIntroduction\nElectricity and heat production account for 25% of yearly emissions, approximately 50GtCO2-eq (IPCC 2014, p. 46f). Any increase in efficiency can have a significant impact. However, energy supply is a critical and sensitive system, where blackouts and brownouts are unacceptable. A new technology must guarantee correctness. Day-to-day grid operation requires generator output scheduling. A Transmission System Operator (TSO) must optimize power purchase from different generators, each with different and potentially nonlinear costs and CO2 emissions per produced megajoule. Minimizing cost is known as Optimal Power Flow (OPF), and optimizing it exactly (referred to as ACOPF) has been proven to be NP-hard (Bienstock and Verma 2015). The problem size is expected to increase with the proliferation of small renewable generators. Significant progress has been made in recent decades (Cain et al. 2012). However, in day-to-day operations, which require solving OPF within a minute every five minutes, TSOs rely on linear approximations known as DCOPF. These approximations produce inefficient solutions, wasting power and resulting in hundreds of megatons of CO2-equivalent emissions per year.\n\nWe propose using machine learning to produce a solution to the OPF problem. Although the solution may not be optimal or even physically implementable, we can use it to warm-start an ACOPF solver. Combining both approaches, we gain the best of both worlds: faster execution time and guaranteed legality. This has previously been proposed by Guha et al. (2019), but they used a feed-forward network and faced issues with scalability and changing network geometry. They also did not integrate their results into an actual ACOPF optimizer.\n\nApproach and Experiments\nOPF is a complex problem governed by many nonlinear equations and constraints. We refer to Frank and Rebennack (2016) for details on the problem formulation. For the following, we approximate the problem as a graph: physical buses (each containing loads, generators, and/or shunts) are connected by branches. Each component is characterized by physical parameters (e.g., a branch's resistance) and constraints (e.g., a generator's maximum power output). By modeling the problem as a graph, we can apply Graph Neural Networks (GNNs) to it. This approach allows independence of the actual network topology, is data-efficient, and is suited to the sparse connectivity of a power network. We rely on PowerModels.jl (Coffrin et al. 2018) and use IPOPT (Wächter and Biegler 2006) as an OPF solver. We implement the model using PyTorch (Paszke et al. 2017) and the PyTorch-Geometric package (Fey and Lenssen 2019).\n\n2.1 Model\nIn most applications and benchmarks, GNNs expect homogeneous nodes and edges connecting them. However, we can have multiple generators connected to one bus. We treat buses as connecting to sets of generators, loads, and shunts. Following Zaheer et al. (2017), we compute a representation of each component, then concatenate their summed features to the bus: \n\nch = fn(c_i), o_0 = fn(||b_i || ∑ s∈N_sh ∥ ∑ g∈N_g ∥ ∑ l∈N_l h)\n\nwhere c_i is the input feature of the shunt, bus, generator, or load, h is the encoded representation, o_0 is the 0th layer output, f is a set of learned functions (parameterized neural networks), and || is concatenation. N refers to the corresponding neighbors of each node. We then compute edge features e and node features for layer n as:\n\ne_n = fn(e_n-1 || o_n)\nb_n = fn(||b_n-1 || e_n-1 || o_n)"
}